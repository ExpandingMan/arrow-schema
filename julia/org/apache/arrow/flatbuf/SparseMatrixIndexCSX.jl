# automatically generated by the FlatBuffers compiler, do not modify

org.apache.arrow.flatbuf.eval(quote


FlatBuffers.@with_kw mutable struct SparseMatrixIndexCSX{A, B, C, D}
#=
#  Compressed Sparse format, that is matrix-specific.
=#
#=
#  Which axis, row or column, is compressed
=#
    compressedAxis::SparseMatrixCompressedAxis = 0
#=
#  The type of values in indptrBuffer
=#
    indptrType::Union{A, Nothing} = nothing
#=
#  indptrBuffer stores the location and size of indptr array that
#  represents the range of the rows.
#  The i-th row spans from indptr[i] to indptr[i+1] in the data.
#  The length of this array is 1 + (the number of rows), and the type
#  of index value is long.
# 
#  For example, let X be the following 6x4 matrix:
# 
#    X := [[0, 1, 2, 0],
#          [0, 0, 3, 0],
#          [0, 4, 0, 5],
#          [0, 0, 0, 0],
#          [6, 0, 7, 8],
#          [0, 9, 0, 0]].
# 
#  The array of non-zero values in X is:
# 
#    values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
# 
#  And the indptr of X is:
# 
#    indptr(X) = [0, 2, 3, 5, 5, 8, 10].
=#
    indptrBuffer::Union{B, Nothing} = nothing
#=
#  The type of values in indicesBuffer
=#
    indicesType::Union{C, Nothing} = nothing
#=
#  indicesBuffer stores the location and size of the array that
#  contains the column indices of the corresponding non-zero values.
#  The type of index value is long.
# 
#  For example, the indices of the above X is:
# 
#    indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
# 
#  Note that the indices are sorted in lexicographical order for each row.
=#
    indicesBuffer::Union{D, Nothing} = nothing
end
FlatBuffers.@ALIGN(SparseMatrixIndexCSX, 1)
FlatBuffers.slot_offsets(::Type{T}) where {T<:SparseMatrixIndexCSX} = [
    0x00000004, 0x00000006, 0x00000008, 0x0000000A, 
    0x0000000C
]

SparseMatrixIndexCSX(buf::AbstractVector{UInt8}) = FlatBuffers.read(SparseMatrixIndexCSX{Int, Buffer, Int, Buffer}, buf)
SparseMatrixIndexCSX(io::IO) = FlatBuffers.deserialize(io, SparseMatrixIndexCSX{Int, Buffer, Int, Buffer})

end)

