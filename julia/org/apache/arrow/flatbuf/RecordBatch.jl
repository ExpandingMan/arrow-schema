# automatically generated by the FlatBuffers compiler, do not modify

org.apache.arrow.flatbuf.eval(quote


FlatBuffers.@with_kw mutable struct RecordBatch{A, B, C}
#=
#  A data header describing the shared memory layout of a "record" or "row"
#  batch. Some systems call this a "row batch" internally and others a "record
#  batch".
=#
#=
#  number of records / rows. The arrays in the batch should all have this
#  length
=#
    length::Int64 = 0
#=
#  Nodes correspond to the pre-ordered flattened logical schema
=#
    nodes::Vector{A} = []
#=
#  Buffers correspond to the pre-ordered flattened buffer tree
# 
#  The number of buffers appended to this list depends on the schema. For
#  example, most primitive arrays will have 2 buffers, 1 for the validity
#  bitmap and 1 for the values. For struct arrays, there will only be a
#  single buffer for the validity (nulls) bitmap
=#
    buffers::Vector{B} = []
#=
#  Optional compression of the message body
=#
    compression::Union{C, Nothing} = nothing
end
FlatBuffers.@ALIGN(RecordBatch, 1)
FlatBuffers.slot_offsets(::Type{T}) where {T<:RecordBatch} = [
    0x00000004, 0x00000006, 0x00000008, 0x0000000A
]

RecordBatch(buf::AbstractVector{UInt8}) = FlatBuffers.read(RecordBatch{FieldNode, Buffer, BodyCompression}, buf)
RecordBatch(io::IO) = FlatBuffers.deserialize(io, RecordBatch{FieldNode, Buffer, BodyCompression})

end)

