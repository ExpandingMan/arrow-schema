# automatically generated by the FlatBuffers compiler, do not modify

org.apache.arrow.flatbuf.eval(quote


FlatBuffers.@with_kw mutable struct SparseTensorIndexCOO{A, B}
#=
#  ----------------------------------------------------------------------
#  EXPERIMENTAL: Data structures for sparse tensors
#  Coordinate (COO) format of sparse tensor index.
# 
#  COO's index list are represented as a NxM matrix,
#  where N is the number of non-zero values,
#  and M is the number of dimensions of a sparse tensor.
# 
#  indicesBuffer stores the location and size of the data of this indices
#  matrix.  The value type and the stride of the indices matrix is
#  specified in indicesType and indicesStrides fields.
# 
#  For example, let X be a 2x3x4x5 tensor, and it has the following
#  6 non-zero values:
# 
#    X[0, 1, 2, 0] := 1
#    X[1, 1, 2, 3] := 2
#    X[0, 2, 1, 0] := 3
#    X[0, 1, 3, 0] := 4
#    X[0, 1, 2, 1] := 5
#    X[1, 2, 0, 4] := 6
# 
#  In COO format, the index matrix of X is the following 4x6 matrix:
# 
#    [[0, 0, 0, 0, 1, 1],
#     [1, 1, 1, 2, 1, 2],
#     [2, 2, 3, 1, 2, 0],
#     [0, 1, 0, 0, 3, 4]]
# 
#  Note that the indices are sorted in lexicographical order.
=#
#=
#  The type of values in indicesBuffer
=#
    indicesType::Union{A, Nothing} = nothing
#=
#  Non-negative byte offsets to advance one value cell along each dimension
#  If omitted, default to row-major order (C-like).
=#
    indicesStrides::Vector{Int64} = []
#=
#  The location and size of the indices matrix's data
=#
    indicesBuffer::Union{B, Nothing} = nothing
end
FlatBuffers.@ALIGN(SparseTensorIndexCOO, 1)
FlatBuffers.slot_offsets(::Type{T}) where {T<:SparseTensorIndexCOO} = [
    0x00000004, 0x00000006, 0x00000008
]

SparseTensorIndexCOO(buf::AbstractVector{UInt8}) = FlatBuffers.read(SparseTensorIndexCOO{Int, Buffer}, buf)
SparseTensorIndexCOO(io::IO) = FlatBuffers.deserialize(io, SparseTensorIndexCOO{Int, Buffer})

end)

